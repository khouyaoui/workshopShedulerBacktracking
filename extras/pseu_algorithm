/**
 *
 *  workShopScheduler
 * Restricciones:
 * - solapamento con otros talleres
 * - compatibilidad en matriz cuadrada y simétrica de N talleres
 * - M[i][j]   <--->  M[j][i]  habrá un 1 o 0
 * 1 --> taller compatible

 1)
 a) ¿Es posible usar tupla para representación de una solución?
 -si, un array de n enteros que representarán a n talleres
 b) funciones auxiliares:
 buena()     //se ejecuta después de tomar la decisión de colocar el taller en el horario
 solucion()  // se han colocado todos los talleres en el horario?
 tratarSolucion()
 2) solución y su representación:
 Tipos
 Configuración = array [1…n] de entero (cada int corresponde a la posición de un taller)
 fintipos

 // forma incremental
 colocar de taller en taller en el horario







 3) Arbol de busqueda:
 altura: nTalleres
 anchura: n*m    n=horas del dia     m=días semana [ L-M-M-J-V ]

 anchura; (2 voy o no al taller) ir al taller o no!

 Altura, n decisiones a tomar, donde colocar el taller (n talleres)

 (N de hojas del árbol de búsqueda = 2n)

 -	Comprobar que no haya solapamiento sobre otro x[k]
 -	Comprobar la compatibilidad entes estos

 * 0 --> taller incompatible
 * 1 --> taller compatible
 */

4) Codificación:
    x -->  array de n posi de talleres -- > 1 ir 0 no ir
//k --> nivel en la tabla horario (id del taller).
//n --> representa la cantidad de talleres
array 0/1 ir o no al taller
prepararRecorridoNivel(x,k)
x [ k ] :=  -1  no sabemos si vamos o no (1 =ir al taller , 0 = no ir al taller)
haySucesor(x, y)
x [ k ] < 1     // 0 entra 1 no entra

int x [] = new int { 0,1,2,3,4,5….n };        JAVA
String talleres [] = new String {“DDD”,”PAR-I”,”PAR-II”,”ADS”….n};   JAVA


SiguienteHermano( x, k )
x [ k ] = x [ k ]++      ¿??????    x [ k ] = x [ k +1]
X[k]  pos 0   ---------->    x[k]  pos 1
solucion(x,k)
k = n	//  cuando la k sea igual a la cantidad de talleres.
    .. evitar solapamiento de talleres + consultar si los talleres son compatibles [][]










M [][]
Función buena (x: configuración; k: entero ) devuelve booleano
var
    indice: entero
libre: booleano
incompatible: booleano
finvar
índice:= 1
libre := verdadero // no esta ocupada la hora
incompatible := verdadero
si x [ k ] == 0
devuelve cierto
mientras índice < k &&  libre hacer       //
si x [ índice ] == 1 entonces      Asignatura seleccionada
si M [ índice ] [ k ] == 1 entonces      compatibilidad
incompatible := falso   // son compatibles
Si x[indice].timeTable == x[k].timeTable entonces
//timeTable representa hora/día (int)
libre := falso
finsi
finsi
finsi
índice := índice + 1
finmientras
devuelve (libre   ^ ¬incompatible)
finfuncion





//segundo
proc tratarSolucion(x: configuracion; k: entero)
Var
i,horas: entero
Finvar
finsi
finproc




















Proc Backtracking (x: configuracion; k: entero)
prepararRecorrigoNivel(x, k)
mientras x[k] < 1 hacer                   // mientras haya sucesor
x[k]++    // SiguienteHermano
opcion caso k = n:    //k==x.size
caso buena(x,k):
tratarSolucion(x,k+1)
caso ¬buena(x,k): // nada
caso k < n:
caso buena(x,k):
Backtracking(x,k+1)
caso ¬buena(x,k): // no hacer nada, poda
finopcion
finmientras
finproc








(__tratar solución quedarnos con la mejor)
